# The Power of Living Systems

_Captured: 2016-02-10 at 12:06 from [hintjens.com](http://hintjens.com/blog:74)_

A "Living System" is one that grows into its environment, by self-organizing around opportunities. Living systems can last for a long time, adapt well to change, and thus be highly successful. By contrast, "Planned Systems" tend to be fragile, poor at coping with change, and thus short-lived. In this article I'll explain Living Systems, of software and people, and how to grow them.

## Why "Living Systems"?

> Since the beginning, life has relied upon the transmission of messages. -- [RFC 3164 (syslog)](http://www.ietf.org/rfc/rfc3164.txt)

[Wikipedia writes](http://en.wikipedia.org/wiki/Living_systems), "Living systems are open self-organizing living things that interact with their environment. These systems are maintained by flows of information, energy and matter." The term was originated by psychologist James Grier Miller to formalize the concept of life.

I want to use the term to define a new metaphor for software systems and organizations, the two types of system I'm most interested in. The two are more than just similar. Software is the product of an group of people, and as Conway observed, the structure of a software system mimics the structure of the organization that produces it. I've written that "the physics of software is the physics of people," and by that I meant psychology.

Most software products today are highly planned, and they fail as living systems. They are essentially dead on delivery, sold by force and bluff. For a software to be a "living system", it must be used by the organization that builds it, and it then lives or dies along with that organization. An "organization" can be much larger than one company or one team. It can consist of thousands of teams, businesses, customers and suppliers, connected in ineffable yet vitally real networks.

Nowhere is this more clear than the Internet, a Living System of software, of people, of businesses and other organizations. The organization that built the Internet is nothing less than human society itself. There are many Living Systems, all around us. It is a strangely simple truth: that the better we get at writing large-scale software systems, they more they resemble the real world around us.

In contrast to Living Systems, we have Planned Systems. It is far easier to plan a system than to grow it. However, plans are inevitably built on wrong assumptions and poor judgments. Planned Systems look attractive and efficient from some perspectives, yet they inevitably fail catastrophically. Real life provides many examples, such as collective farming, planned cities, Microsoft Windows 8, and so on.

In the software business, this Living vs. Planned dichotomy is best expressed by free software vs. closed source. Free software (and its corporate cousin open source) usually grows out of real use, where as closed source is usually planned. This is mainly why I don't work on closed source: it dies rapidly and predictably. I prefer my work to survive as long as possible.

I'll make a few broad claims, starting with: _the most successful large-scale software systems are Living Systems_. That is, in a competitive market, a Living System will wipe out any competing Planned Systems. It will recognize and solve real problems faster, cheaper, and more accurately. If your business depends on a Planned System, you are vulnerable to attack by a Living System.

The second claim I'll make is that this also applies to organizations. If your company is a Planned System, it is already dead. Whereas if your company operates as a Living System, it can dominate its market. Interestingly, when two Living Systems meet, they don't usually fight. Rather, they specialize into different areas, and they then merge to form a single Living System. Competition and conflict usually work for the benefit of the Living System, even if individual components fail.

Let me take this question of conflict and competition further. Of course individuals do compete, and quite harshly sometimes. This is our biological imperative. However we also have a biological imperative to collaborate, a far more profitable strategy, most of the time. A Living System embraces competition between individuals, and survives the failure of individual components. It actually depends on that process of competition and failure. A Planned System is essentially trying to act as a single individual, and cannot tolerate internal competition, nor failure of individual components.

## What do Living Systems Look Like?

A Living System consists of a large number of loosely-coupled components. It is essentially spread out in space (thus, "distributed"), and in time (thus, "asynchronous"). That means things happen in unpredictable places, and at unexpected times. To a central planner, this looks like dangerous chaos.

In a Planned System, by contrast, the times and places of events are meticulously scripted. The focus is on "command and control," where decisions are made centrally and communicated to the structure. Planned Systems are essentially hierarchical, for this is the optimum way to communicate decisions rapidly down from the top.

We _build_ a Planned System, whereas a Living System _grows_ itself. My goal is to learn, and to teach, how to grow Living Systems artificially. I'm studying the genes and patterns of care and nurture for a self-growing system. In fact I'm talking about creating artificial life, and artificial intelligence, though in a shape that traditional AI researchers might not recognize. I don't believe individuals components -- including you and me -- can be "intelligent" at all, except in a narrow and superficial sense: intelligence is a property of systems.

Living Systems are typified by their lack of central planning or decision making. Look at a software project and ask, "who is the designer?" If there is a clear designer, individual or organization (and there almost always is), that is a Planned System. A Living System has no designer, no road-maps, no clear future plans except "survive and grow."

A Living System looks more like Adam Smith's free market than Stalin's Five Year Plan. Economics, politics, and psychology are as important -- perhaps more important -- in growing successful Living Systems as technology. A free market depends on several key things: clear laws, standards, contracts, and fair regulation. A Living System likewise depends on these.

So whereas a Living System has no central planner, it may have central regulators. Let me explain the difference. In a planned city, a committee decides where to build schools, homes, factories, offices, railway stations, shops, sports facilities, and so on. In a Living City, all these are decided by independent agents (school boards, businesses, home owners, etc.) and the city regulates the provision of electricity and clean water, the disposal of garbage, and so on. Further, the city runs police and courts, as regulators, to dissuade criminals and cheats.

A regulator makes laws that define a fair market, and then enforces those laws. Units of measurement, currencies, contracts, and such. In software systems, these laws are, for instance, the source code license, and contribution policy. A fair market lets anyone create a new venture, and compete with other ventures. To allow true competition (meaning, free choice by customers), clients can demand clear contracts, which in software terms are documented APIs and protocols.

The DNA of a Living Systems is essentially a set of regulated contracts. Thus the Internet is grown out of a set of RFCs (protocols called Requests for Comments), regulated by the Internet Engineering Task Force (IETF). Living cities are grown out of criminal and civil laws, standards for water and power and waste, transport, and so on.

If all strategies were honest, there would be no need for regulators. However any Living System will be vulnerable to cheating strategies. A certain segment of people, for instance, are systematic or opportunistic cheats. Given a market, they will always seek a way to convert value to their own benefit, even at a higher cost to others. They will lie, steal, deceive, coerce, and so on.

Without resistance against such cheats, the market will suffer, and the system will eventually die. Top-down authority is one defense against cheats. However it has a significant vulnerability: cheats can, and often do, capture the authority itself. In Living Systems, cheats can try to capture the regulators, and this happens in real life all the time.

When cheats capture the regulators of real-life Living Systems, the usual response is to move away, if we can. In open source software systems, we can fork and continue under a better regulator. This is why forking is an essential freedom, rather than a failure. Since forking can also be a strategy for capture, a fork-safe license (GPL or similar) is best for Living Systems in software.

Living Systems grow, constantly and organically. This is their most visible trait: the lack of the usual massive construction efforts. Rather, you will see a smooth flow of small changes. It may seem boring or unambitious. However, it is a better algorithm for survival. A Living System must do two things. First, it must solve some profitable set of problems. Second, it must adapt and change over time, as its environment changes.

Shifting a Planned System to cope with a changing environment is very hard, often impossible. Resources define power. Thus, Planned Systems actively and aggressively resist change, deny it, and when it becomes inevitable, they die catastrophically. However, a Living System feeds off change. It makes no distinction between exploring the landscape of problems of "now" and of "tomorrow." It grows through continuous learning. To actually destroy a Living System you have to do widespread damage to it, which is hard when a successful Living System has spread wide.

To a Living System, small amounts of damage are indistinguishable from normal activity. In fact Living Systems thrive on challenge, so long as it is not overwhelming. Challenge is what allows components to compete, and develop better answers. What does not kill a Living System makes it stronger.

So, as Living Systems learn and move quickly and opportunistically into new areas, they will tend to thrive and grow dominant, wiping out any competing Planned Systems. They can react rapidly, shifting resources around to areas where they are more valuable. And since they do not need any upfront coordination to act, they can scale to any size. Zero upfront coordination means infinite scale.

## Components of a Living System

Let's now look at the individual components of a Living System. Remember that a Living System resembles a free market, where components compete to provide some identifiable and measurable service. The components of a Living System have some traits that set them apart from the components of a planned system.

Every component of a Living System has a clear set of owners and investors, and ownership is usually highly localized (in contrast to a Planned System, where all components have the same owners). Components organize into chains of suppliers and clients, and they have identities, names, and addresses, so that clients can find them. One classic way to cheat is for one group to provide a poor quality component that claims to be a high-quality one. Thus the regulator may have to enforce identity, and protect investment in an identity.

Components are, as far as possible, location independent. That creates a larger, and more efficient free market. It means that we strive for location independence as a feature of our Living System. This is contrary to a Planned System, where location is highly significant, and where there is little or no competition between components.

Similarly, components may come and go in time, quite arbitrarily. There are no guarantees that a component we depend on today will still exist, or be available tomorrow. This may sound fragile, yet it is highly robust. Rather than depending on specific components, we depend on contracts. If our need is real, there will be many alternatives. If one disappears, another will take its place. If you miss one taxi, you will catch another.

Components are highly independent, decoupled from one another. That is, they exist and change at their own rate, in their own direction. A change in one component is essentially invisible to another component except through its public interfaces. This freedom is essential to a free market, driven by specialization and trade. Thus one component may focus on speed, while another on security.

Since there is no centralized decision about what components exist, nor who makes them, they will be highly heterogeneous, and this diversity is essential to the intelligence of the overall system. A set of diverse components in a Living System, connected in a free market, will solve large problems faster, and more accurately, than a monolithic Planned System.

Components are abstracted, meaning they may represent entire systems in themselves. For instance a web address can represent a single, small piece of software (one web server), or it may represent a massive infrastructure (an Internet business). It is up to each group of owners to decide whether they build Living Systems or Planned Systems, in turn. A Living System will happily embrace Planned Systems as components. The opposite isn't true.

Components avoid upfront consensus, also known as "shared mutable state". Every component has knowledge, and they may share knowledge, yet they do so asynchronously. So while the Living System represents a large, coherent pool of knowledge, there is no guaranteed consistency between components. This may seem paradoxical. Surely every person in a meeting, for instance, agrees on the agenda for the meeting?

In fact meetings, with their agendas and minutes, are the epitome of the shared mutable state that a Planned System depends on. Planned Systems cannot function without systematic upfront agreement. In concurrent software design, we use "locks" to achieve the same result. It is provably true that a software system that uses locks to share state between components will not scale. You can try to make distributed software as a Planned System: it starts easily yet scales poorly, if at all. Whereas a Living System takes a little more thought at the start, and then scales without limit.

Finally, components are lazy and opportunistic. They only work when there are tasks waiting, and they only change and grow when there are new, profitable opportunities. This means components can remain lightweight and minimalistic. Further, they can solve the "problem landscape" much more accurately, without excess baggage. In a Planned System by contrast, components are built upfront, on the assumption of future problems, or at best, knowledge of past problems.

An example: in a planned conference, the organizers choose speakers on certain topics, based on their experience of the previous year. Now, one month before the conference, a significant event drives public demand for speakers on a totally different topic. How long will it take the conference to react? A participant-driven conference can react in real-time, whereas a planned conference will take a full year to respond.

## Protocols of a Living System

The components of a Living System are connected in relationships. Each relationship consists of a flow of information, knowledge, or requests, in both directions. The best way to model such relationship seems to be as discrete events, or "messages," that carry a formalized set of interactions we call "protocols."

In natural Living Systems, we also see messages and protocols. Cells, for instance, communicate with chemical messages. We humans appear to communicate with a set of protocols that underly our human languages. For instance, male-dominated hierarchies are a consistent feature of human society, suggesting that the command-and-control protocols they depend on are built-in to our minds, not learned. I'd hypothesize that the male mind, driven by the ancestral need to plan hunting parties, is responsible for Planned Systems.

Protocols have a number of common patterns. We see broadcast protocols where one component signals to many listeners. A broadcast protocol is typically one-way. The signaler may, in rare occasions, get feedback from a few listeners.

We see one-to-one protocols where two components exchange knowledge, tasks, requests, and so on. One-to-one protocols can be more or less chatty, and ideally are fully asynchronous. Chattier protocols take longer to conclude, thus raising overall "latency." For example if I'm cooking a pizza and I have to confirm every ingredient, it will take longer. "Do you like mushrooms?" "How about garlic?" "Ok, what kind of cheese do you prefer?"

The ideal relationships aim for lowest realistic latency, since the latency of the overall system is the sum of the latency of its entire supply chain. That is, if I'm making a meal, and I have to spend one minute solving the "pizza" issue, that adds one minute to the overall preparation time. In an asynchronous low-latency dialog, I'd ask all the questions at once, and deal with the answers as I got them back, one by one.

To make effective asynchronous systems we need queues, and smart queuing strategies. Ideally, we have queues at any point where messages may arrive, and we push messages as close to their consumers as possible, to reduce latency. We need strategies to deal with full queues (space is not infinite): it might be to throw away older messages, or to pause the sender (this works for one-to-one dialogs, not for one-to-many). We may need multiple incoming queues, one per flow, and the ability to wait for a message on any of these queues.

The protocols of a Living System are highly ritualized. They implement formal contracts. If I ask, "Do you like garlic?" then I expect a yes/no answer. A discussion about the weather is a breach of contract. When we're growing our own Living Systems, we have to write the protocols down, so they can be learned and verified. The simpler and clearer, the better. Complex, arcane protocols are expensive to learn and implement, which distorts the free market.

Some Living Systems use earned trust, together with identity, in place of verifiable contracts. This can be a valuable short-hand, especially when exchanging knowledge, though it is also vulnerable to cheats (frauds). An alternative is to ensure that every contract is verifiable, backed by meta-contracts on performance. This is often better for trading work. Any taxi driver is fine, so long as drive to the right address and don't over-charge. However we want our news from trusted sources.

Once we have testable contracts we can deal with violations. One strategy is to fail, and let someone else deal with it. Another is to discard that peer and try another. However, after a contract violation, you generally don't want to continue blindly, as that can cause wider damage.

## Case Study: the ZeroMQ Community

The ZeroMQ community is a Living System of people that builds a Living System of software (the software collection under the same name). Though I originally designed the ZeroMQ community with most of the properties of a Living System, it only really came true in early 2012, when the community rejected its central planners.

The community consists of a large number of loosely-coupled projects that share a common goal, which is to provide the queuing and messaging needs for other software systems. I've argued, and believe, that only a Living System can use ZeroMQ optimally.

The ZeroMQ projects are connected into a supply chain by formalized relationships, over APIs and wire protocols. We spend a large amount of time documenting these APIs and protocols, and ensuring they are testable. Indeed, we do not usually document the internals of components, just their external APIs.

There is no central planning nor coordination. Instead, each project evolves organically as its users invest in patches and improvements. By making this process simple, [the ZeroMQ collaboration contract](http://rfc.zeromq.org/spec:22) ensures that the ZeroMQ organization expands to include all its competent users.

Anyone can start a new ZeroMQ project, or fork an existing one, for competition or experimentation. As a community we encourage this, and so we have multiple competitors at most levels. This works well in practice. The basic license is LGPL v3 or MPL v2, ensuring that forks are always safe (patches can flow in both directions).

The regulator in the ZeroMQ community is a self-elected group, headed by iMatix, the firm that developed the original software. There is not much regulation needed, except to stop abuse of the name "ZeroMQ". Clear documentation of protocols is sufficient to allow clients to verify their suppliers.

ZeroMQ is highly scalable. The cost of adding a new project is close to zero, apart from the discovery cost. Projects communicate asynchronously, using GitHub issues and pull requests. There is little or no upfront coordination. We review code after the fact, and fix poor code through further patches rather than discussion.

ZeroMQ's full transition to a Living System was hard because we had no prior successes to imitate. The bulk of free software projects still depend on significant planning. To go against standard practice was seen as highly eccentric, if not actually insane. The loss of key contributors -- who had provided the authority that central planning depends on -- was seen as potentially catastrophic.

However the ZeroMQ community rapidly expanded into the space left by the central planners, and flourished. We disproved the theory that central planning was essential to quality. In fact we found that without central planning, the software improved significantly in quality and in accuracy. Whereas the ZeroMQ development branch had been highly unstable, experimental, and discordant with users' needs, it became mostly stable, trusted, and a close fit for users' needs.

Today we can hold the ZeroMQ community as a worked example of how to do Living Systems "right." It is all the more valuable as data since there have been numerous attempts to replace it, both by the fleeing central planners, and by other teams. Noticeably, every Planned System that claimed to be "better than ZeroMQ" has failed, whereas every Living System that began by competing with ZeroMQ ended up becoming a valuable part of it.

## Transforming into a Living System

Can we turn a Planned System into a Living System? If we assume we have the technical right (consensus from enough participants, or legal right through software licensing), what are the practical requirements?

The most difficult part will be to get the size of components right. This will often mean breaking up existing components, and creating new ones. That can be catastrophic if done in too many places at once. Thus, in a larger migration, you would start in one area, refactor that, and then grow the resulting culture out.

Components are usually sized around the people, so a good size is "the work that a few people can do." The scale of a Living System comes from adding more components, and allowing them to use and replace each other in whatever fashion makes sense locally, not increasing individual component size. A component is too small when it cannot provide a full service by itself, and it is too large when it does not focus on one thing.

Finally, you need the contracts. For a software system, we have had good results simply by taking the [the ZeroMQ C4.1 process contract](http://rfc.zeromq.org/spec:22), and using that together with a code style guide and the software license. For several reasons, I strongly recommend a share-alike license, such as LGPL (my thesis is that if you use a leaky license like Apache or BSD, you in fact won't get a successful Living System at all).

Launching such a Living System in the past was difficult, as self-organizing software ecologies were poorly documented and little understood. We lacked empirical evidence that processes like C4.1 could work, let alone work so well. As far as I know, this was the first documented contract for a Living System in software.

## Economics of Living Systems

How do we make money from free software? It is a question I'm often asked. The answer comes in various forms depending on whether I'm talking to individuals, to small firms, or to large firms.

A key understanding of Living Systems is that they are essentially about economics. No component exists for random reasons. However, to offer a choice between selfishness and altruism is a false dichotomy. Living Systems are driven by selfishness and altruism at the same time. It is a basic theory of economics: by selfish specialization and trade, we create common wealth. It is the human species' superpower: specialization and trade at a massive scale, between individuals, families, generations, villages, cities, and entire regions.

A Living System is owned by all participants, so it can be harder to measure its value, whereas a Planned System, owned by a few at the top, can have very visible value, to its owners and outside observers. However the overall value and economic power of a Living System will always overwhelm any competing Planned System. A Living System can be incredibly profitable, its profits are just widely distributed among all its participants.

This is the first answer: a Living System can kill competing Planned Systems, and thus liberate large amounts of captive value, which can be absorbed by the Living System. We see this in real life, where free market economies out-perform planned economies, leading to movement of skilled labor (value) from the latter to the former.

The second answer is that we can build new markets on top of successful Living Systems, that are impossible on Planned Systems. The Internet is a clear example of this: it has enabled a massive new economy that was impossible on older networks. Those new markets can be very profitable.

A Planned System can only survive by taking value away from its components. In many ways, it resembles a cult, and depends on cult techniques like brain washing, where a few prosper at the expense of many. Planned Systems are inherently unethical, as well as unsustainable. There is an inherent morality in a fair and free market, despite the large number of of Planned Systems that claim to represent "the market."

## Conclusions

In this essay I've looked at artificial Living Systems, which imitate and can be modeled on real living systems. Living Systems are spread out in space and time. They consist of large numbers of independently owned components that work together, competing and collaborating, in a free market for services, labor, resources, and knowledge. These components evolve independently, under pressure from their market. They live and die according to their success in finding accurate answers to real problems faced by their clients.

The components in a Living System communicate asynchronously by passing messages around, in various patterns. These flows are highly ritualized, in the form of protocols. The more accurate the protocol, the easier it is for clients to choose suppliers freely, and the more efficient the market.

A Living System has no central controlling owner, though it may elect authorities to regulate (define, and enforce) contracts. It has no single points of failure. Rather than treating failure as exceptional and to be avoided, it uses failure as a basic learning technique. Inaccurate components are allowed to fail and are discarded rapidly, and replaced by more accurate components.

Living Systems grow by learning, into supply chains that connect components to the external environment. We can measure the efficiency of a Living System by looking at overall latency as a problem enters the system, and a response emerges. Such latencies can vary from years in Planned Systems to hours in highly adaptive Living Systems.

Living Systems thus organize opportunistically, accurately judging the relative cost of a given problem, and the value of solving it. Unlike Planned Systems, they are driven by live data rather than assumptions, beliefs, or old data. This lets them operate more accurately, faster, and cheaper than Planned Systems.

To build a large scale Living System in software, build a Living System of people. The two will co-evolve and done correctly, will dominate any given market. Whereas competing Planned Systems will fail as whole units, competing Living Systems will tend to specialize into different areas, and then merge into a single unified Living System.

For further reading on similar topics, buy the book "Culture & Empire: Digital Revolution" from Pieter Hintjens on Amazon.com, in ebook or paper form.

  


While ZeroMQ gives you a powerful communications engine to use in many different ways, building a conventional server is still fairly solid work. We use the ROUTER socket for that, managing the state for each individual client connection. Today I'll present a new tool -- [zproto](https://github.com/zeromq/zproto) -- that generates whole servers, in C, from state machine models.

## Quick Background to zproto

zproto is based on work I did for Chapter 7 of the ZeroMQ book, used in FileMQ, Zyre, and several other projects. It's a collection of code generation tools that take models and turn them into perfect code.

iMatix used to do code generation as our main business. We gotâ€¦ very good at it. There are lots of ways to generate code, and the most powerful and sophisticated code generator ever built by mankind lives on Github.com at [imatix/gsl](https://github.com/imatix/gsl). It's an interpreter for programs that eat models (self-describing documents) and spew out text of any shape and form.

The only problem with sophisticated magic like GSL is that it quickly excludes other people. So in ZeroMQ I've been very careful to not do a lot of code generation, only opening that mysterious black box when there was real need.

The first case was in CZMQ, to generate the classes for ZeroMQ socket options. Then in CZMQ, to [generate project files](https://github.com/zeromq/czmq/tree/master/model) (for various build systems) from [a single project.xml](https://github.com/zeromq/czmq/blob/master/model/project.xml) file. Yes, we still use XML models. It's actually a good use case for simple schema-free XML.

Then I started generating binary codecs for protocols, [starting with FILEMQ](https://github.com/zeromq/filemq/blob/master/model/fmq_msg.xml). We used these codecs for a few different projects and they started to be quite solid. Something like a protobufs for ZeroMQ. You can see that the generated code [looks as good](https://github.com/zeromq/filemq/blob/master/include/fmq_msg.h) as hand-written code. It's actually better: [more consistent, with fewer errors](https://github.com/zeromq/filemq/blob/master/src/fmq_msg.c).

Finally, I drew back on an even older iMatix speciality, which was state machines. My first free software tool was [Libero](http://legacy.imatix.com/html/libero/), a great tool for designing code as state machines and producing lovely, solid engines in pretty much any language. Libero predates GSL, so isn't as flexible. However it uses a very elegant and simple state-event-action model.

The Libero model is especially good at designing server-side logic, where you want to capture the exact state machine for a client connection, from start to end. This happens to be one of the more solid problems in ZeroMQ architecture: how to build capable protocol servers. We do a lot of this, it turns out. You can do only so much with low-level patterns like pub-sub and push-pull. Quite soon you need to implement stateful services.

So this is what I made: a GSL code generator that takes a finite-state machine model inspired by Libero, and turns out a full working server. The current code generator produces C (that builds on CZMQ). In this article I'll explain briefly how this works, and how to use it.

## The State Machine Model

State machines are a little unusual, conceptually. If you're not familiar with them it'll take a few days before they click. The Libero model is fairly simple and high level, meant to be designed and understood by humans:

  * The machine exists in one of a number of named _states_. By convention the machine starts in the first state.
  * In each state, the machine accepts one of a set of named _events_. Unhandled events are either ignored or cause the machine to die, depending on your taste.
  * Given an event in a state, the machine executes a list of _actions_, which correspond to your code.
  * After executing the actions the machine moves to the _next state_. An empty next state means "stay in same state".
  * In the next state, the machine either continues with an _internal event_ produced by the previous actions, or waits for an _external event_ coming as a protocol command.
  * Any action can raise an _exception event_ that interrupts the flow through the action list and to the next state.
  * A _defaults state_ collects events that may occur in any state, together with their actions.

## The zproto Server Model

The zproto_server_c.gsl code generator outputs a single .h file called an _engine_ that does the hard work. If needed, it'll also generate you a skeleton .c file for your server, which you edit and build. It doesn't re-create that file again, though it will append new action stubs.

The server is a class that exposes an API like this (taken from the [zeromq/zbroker](https://github.com/zeromq/zbroker/tree/master/src) zpipes_server, a good example):
    
    
    //  Create a new zpipes_server
    zpipes_server_t *
        zpipes_server_new (void);
    
    //  Destroy the zpipes_server
    void
        zpipes_server_destroy (zpipes_server_t **self_p);
    
    //  Load server configuration data
    void
        zpipes_server_configure (zpipes_server_t *self, const char *config_file);
    
    //  Set one configuration path value
    void
        zpipes_server_setoption (zpipes_server_t *self, const char *path, const char *value);
    
    //  Binds the server to an endpoint, formatted as printf string
    long
        zpipes_server_bind (zpipes_server_t *self, const char *format, ...);
    
    //  Self test of this class
    void
        zpipes_server_test (bool verbose);
    

Rather than run the server as a main program, you write a main program that creates and works with server objects. These run as background services, accepting clients on a ZMQ ROUTER port. The bind method exposes that port to the outside world.

Here's the state machine for the ZPIPES server:
    
    
    <class
        name = "zpipes_server"
        title = "ZPIPES server"
        proto = "zpipes_msg"
        script = "zproto_server_c"
        >
        This is a server implementation for the ZPIPES protocol
        <include filename = "license.xml" />
    
        <!-- State machine for a client connection -->
        <state name = "start">
            <event name = "INPUT" next = "reading">
                <action name = "open pipe for input" />
                <action name = "send" message = "INPUT OK" />
            </event>
            <event name = "OUTPUT" next = "writing">
                <action name = "open pipe for output" />
                <action name = "send" message = "OUTPUT OK" />
            </event>
        </state>
    
        This state allows two protocol commands, READ and CLOSE.
        Names of states, events, and actions are case insensitive.
        By convention we use uppercase for protocol events:
    
        <state name = "reading">
            <event name = "READ" next = "expecting chunk">
                <action name = "expect chunk on pipe" />
            </event>
            <event name = "CLOSE">
                <action name = "close pipe" />
                <action name = "send" message = "CLOSE OK" />
                <action name = "terminate" />
            </event>
        </state>
    
        This internal state shows how we make a decision in the
        state machine. These are three internal events; they can
        happen come immediately from 'expect chunk on pipe', or
        come later from various places. The server can ask for a
        wakeup event (timeout expired). We can also get events
        from other clients' machines.
    
        <state name = "expecting chunk">
            <event name = "have chunk" next = "reading">
                <action name = "clear pending reads" />
                <action name = "fetch chunk from pipe" />
                <action name = "send" message = "READ OK" />
            </event>
            <event name = "pipe terminated" next = "reading">
                <action name = "clear pending reads" />
                <action name = "send" message = "END OF PIPE" />
            </event>
            <event name = "timeout expired" next = "reading">
                <action name = "clear pending reads" />
                <action name = "send" message = "TIMEOUT" />
            </event>
        </state>
    
        <state name = "writing">
            <event name = "WRITE" next = "writing">
                <action name = "store chunk to pipe" />
                <action name = "send" message = "WRITE OK" />
            </event>
            <event name = "CLOSE">
                <action name = "close pipe" />
                <action name = "send" message = "CLOSE OK" />
                <action name = "terminate" />
            </event>
        </state>
    
        The defaults state handles an 'exception_event' (sends
        FAILED back to the client). It also specifies that any
        unrecognized protocol command (an '$other' event) will
        also cause the engine to send FAILED back to the client.
    
        <state name = "defaults">
            <event name = "exception">
                <action name = "send" message = "FAILED" />
                <action name = "terminate" />
            </event>
            <event name = "$other">
                <action name = "send" message = "FAILED" />
            </event>
        </state>
    
        We can define API methods to pass commands back from the
        application through to the engine.
    
        <!-- API methods
        <method name = "somename" return = "number">
            One-line description of method here
            <argument name = "some value" type = "string">What is this argument?</argument>
            <argument name = "some value" type = "number">What is this argument?</argument>
        </method>
        -->
    </class>
    

The generated server manages clients automatically. There's various options to expire dead clients, and so on -- read the zproto_server_c.gsl code to understand more. The state machine applies to *single client connection* from start to finish.

There are two predefined actions: "send" and "terminate". Other actions map to functions in your own code. The engine calls these functions as needed, passing the client context:
    
    
    static void
    store_chunk_to_pipe (client_t *self)
    {
        //  State machine guarantees we're in a valid state for writing
        assert (self->pipe);
        assert (self->writing);
    
        //  Always store chunk on list, even to pass to pending reader
        zlist_append (self->pipe->queue, zpipes_msg_get_chunk (self->request));
        if (self->pipe->reader) {
            send_event (self->pipe->reader, have_chunk_event);
            assert (zlist_size (self->pipe->queue) == 0);
        }
    }
    

There are a set of methods your actions can call:
    
    
    //  Set the next event, needed in at least one action in an internal
    //  state; otherwise the state machine will wait for a message on the
    //  router socket and treat that as the event.
    static void set_next_event (client_t *self, event_t event);
    
    //  Raise an exception with 'event', halting any actions in progress.
    //  Continues execution of actions defined for the exception event.
    static void raise_exception (client_t *self, event_t event);
    
    //  Set wakeup alarm after 'delay' msecs. The next state should
    //  handle the wakeup event. The alarm is cancelled on any other
    //  event.
    static void set_wakeup_event (client_t *self, size_t delay, event_t event);
    
    //  Execute 'event' on specified client. Use this to send events to
    //  other clients. Cancels any wakeup alarm on that client.
    static void send_event (client_t *self, event_t event);
    

## For More Information

Though [the Libero documentation](http://legacy.imatix.com/html/libero/) is quite old now, it's useful as a guide to what's possible with state machines. The Libero model added superstates, substates, and other useful ways to manage larger state machines.

The current working example of the zproto server generator is the [zeromq/zbroker](https://github.com/zeromq/zbroker) project, and specifically the zpipes_server class.

You can find [GSL on Github](https://github.com/imatix/gsl) and there's a [old backgrounder](http://download.imatix.com/mop/) for the so-called "model oriented programming" we used at iMatix.

If you have something to say, comment below or come discuss on zeromq-dev.

  


On October 30 and 31, Marvin Arnold and myself will be organizing a hackathon in Brussels, with the goal: produce a prototype for a fully decentralized Internet. The idea came after Marvin, the guy behind [Unplugged](http://gounplugged.co/) and I were talking about ways to kick off something together.

A while back I proposed building [an "edgenet"](http://theedg.es) built on ZeroMQ, Zyre, and other layers. We did a fundraiser that collected four times the amount I asked for (a token $1,000). Now we've been working hard on pieces of the puzzle (it is a large puzzle), and it feels like a good time to kick things up a notch.

I'm running, every month or so, [courses in Brussels](http://hintjens.com/main:courses) to teach our techniques of contract-driven distributed system development on top of ZeroMQ. So the plan is to take the first of these events and turn that into a hackathon for edgenet, which is a great example of a real distributed system that we could build on top of ZeroMQ.

We have two days, and most of the weekend that follows. There will be food, beer, WiFi, and if I can get my act together, t-shirts for everyone who takes part. This is not going to be a ZeroMQ tutorial. If you come hoping to get kind words and a gentle introduction into how to make a simple application, be warned! We're going to be working fast, focussing on writing and implementing RFCs, building code on GitHub, and interacting with others who can't be present.

Our goal is to get an end-to-end prototype running on Android. That is, a real app that can do real stuff. If we can't get the necessary Android SDK skills, our fallback plan is to run the network on Linux.

A new decentralized Internet is a vast challenge, so I'm going to cut down the problem to its absolute minimum. We need to solve three functional problems (comprising something like seventeen point four gazzilion technical problems):

1\. How to exchange information (text and photos) anonymously between a disconnected group of people, on an arbitrarily large range of topics.  
2\. How to create authentic identities that can collect credit (be it bitcoin or karma), so that people have an economic incentive to participate.  
3\. How to send information directly from one such identity to another, across any distance, in full security.

This is kind of, "How do I rebuild Reddit when there is no Internet?"

The best answer I have at this stage is something like NNTP, modernised to run over ZeroMQ. If you know what that means, very good, come to the head of the class.

You can maybe see why I put the three problems in that order. We know that a global decentralized Internet will depend on billions of nodes to participate and forward data between each other. Only we have this mass of participants can we start doing person-to-person messaging. There are no existing global mesh networks. We do have to make one, as a first step.

If this is sounding insane yet weirdly compelling to you, please give yourself a pat on the back. You can use either hand.

The edgenet proposal -- which though I like, I'm not attached to -- is to create opportunistic "cells" around WiFi hotspots, and then treat these as dial-up links in the old NNTP model. As nodes see nodes, they exchange stuff. There's never any single consistent state. Every node has its view of the world. Perhaps there are nodes with larger memories. Perhaps not. Perhaps there are nodes who don't need to be anonymous, and who can happily route stuff directly from A to B. We'll see.

What tools do we already have? Let me list a few:

  * Marvin has pieces of a BLE (Bluetooth low energy) stack. This could be e.g. a future ZeroMQ transport (remember that ZeroMQ is basically a standardized queuing/routing API over arbitrary transports).
  * We have ZeroMQ, in C++, Java (JeroMQ), .NET (NetMQ), Erlang (ezmq), and C (libzmtp). These all talk the same [ZMTP protocol](http://rfc.zeromq.org/spec:23). Only the C++ stack currently does encryption. Trevor Bernard has plans to add this to JeroMQ.
  * We have various discovery tools in CZMQ (the high level C binding for ZeroMQ), including UDP beaconing and zgossip. CZMQ is also wrapped in lots of languages such as Go and Ruby and Python and even C++ (though the smartest C++ developers are those who switched back to C, IMHO).
  * We have a protocol toolkit called [zproto](https://github.com/zeromq/zproto) that generates protocol stacks in C and Java and Go, with minimal effort. This is like protobufs mixed with ASN.1, without the pain. These days we build every serious ZeroMQ protocol using zproto.
  * We have [Zyre](http://zyre.org), an opportunistic clustering layer that uses CZMQ's discovery to find peers, and then connect them into an IRC-like group chat model. Zyre was always intended as the core of an edgenet cell, Since I began building it in 2012 (in C), it's become quite popular, wrapped in several languages, and also reimplemented in Java (jyre), Python (pyre), and others.

OK. What we do not have, and really need, is people with the skills to wrassle the Android SDK and to build simple and nice Android UIs. I once spent a few months of my life doing that, and it's not my sweet spot. I just don't have the patience for Java. Most of these projects have Android builds, yet when I plug in a phone and run adb, my heart sinks every time. Maybe it's just the post-traumatic effect of too much kimchi and soju.

So in Brussels, on 30 and 31 October (and on 1 and 2 November if needed) we will mash this together with new protocols and new stacks, and aim to get anonymous cat photos floating around a group of phones, tablets, and laptops.

Who is this for?

  * You already know ZeroMQ and you want to push your skill level up several notches.
  * You are passionate about a decentralized Internet and you have some experience with the problem.
  * You are into Android and have no fear of adb, the SDK, and perhaps even kimchi.
  * You know a thing or two about NNTP and can tell me why I'm totally wrong to think of using it.

Ideally, you are OK with C since most of the core work will happen in that language. We use a [nice Python-like C style](http://czmq.zeromq.org/) called [CLASS](http://rfc.zeromq.org/spec:21).

You will have to know how git and github work, to be able to join in. We'll try to set-up a projector with an IRC channel, so that the outside world can chat to us, follow what we're doing, and join in via GitHub pull requests, as per [our usual way of working together](http://rfc.zeromq.org/spec:22).

Instead of making this a paid workshop as was planned, it's going to be free for the first N people who register and who get past the strict entrance requirements. This means emailing me, telling me you loved my book (any book, it's all the same), and then tell me why you have to be there, with whatever arguments you want to add. If you get a seat, and you can't come, you will be free to pass this to someone else. N is variable. At some stage the free seats will be gone.

Alternatively, if you want to come as a paid participant, that is also great. The price will be EUR 1,200 per person for the two days, and the weekend if wanted. Meals will NOT be included in this event. (Mainly, we won't be taking breaks.) iMatix will collect such payments, and issue invoices.

Participants' names will be private though all the code we make will be public, so GitHub throw-aways are totally OK. All code we make will be MPLv2 licensed.

Questions? Comments? Let me know.

  


Who's the purpose of Life? Who's in charge? How much does it cost, and what colors does it come in? Today, I take all these and other Frequently Asked Questions about Life and answer them in a single easy-to-hate blog post.

## Q: What's Life?

Life is the absence of not-Life, much like Beer is the absence of everything except Beer. Put it another way, Life is exactly like a huge planet-wide party involving billions of people and trillions of other life forms, lasting so many years we needed to invent "zero" just to count them, and not just playing the best music and eating the best food, but making it up on the spot.

## Q: What's the purpose of Life and why should I care?

There are several competing theories about this. One popular theory is that you'd better care, otherwise raging demon spirits from an alternate dimension will descend upon you and rip you to shreds with their talons and fangs, whilst simultaneously giving you the power to heal immediately, so that the torture lasts a million years. A less dramatic theory is that Life has no purpose, and whether you care or not doesn't matter a bit, as Life doesn't give a demon's arse either way.

## Q: What are the alternatives? Why is Life better?

Again, there are many theories about this, and some of the most durable and profitable ones -- also called "Religions" -- have developed multiple values of "Life". A less profitable though more scientific view is that Life is binary. You either have it, or you do not. However, Religion eats cake and drinks wine, while Science chews dry crusts.

## Q: This Life sounds great, how do I get one?

Unfortunately, Life is not available for download. You can only get a Life by invitation from two existing Life owners. Also, you cannot reject the invitation. By the time you realize you have received a Life, it is too late to back out.

## Q: How much does a Life cost?

For something that everyone needs and is willing to pay anything for, the surprising answer is that life is free, technically, which is the best kind of free. Some have argued that the price of a Life is a Life, though these are ironically those who usually value Life the lowest.

## Q: What colors does it come in?

Frankly, mostly a shitty brown color, with periods of blue and bright red. However your Life will change colors depending on how you connect it to other Lives. Your Life's current color is often the best sign that you have connected it to the wrong, or the right people.

## Q: Who invented Life? Who's in Charge?

Some people claim that Life was invented by one or more space ghosts who rule the Universe with extraordinary jealousy, paranoia, and Machiavellian cunning. In this story, when things go right it's always thanks to the space ghosts, and when things go wrong, it's always your own fault. The space ghosts of history have no emotions except violent anger and suffocating love, are never wrong, and never say sorry. Happily, space ghosts are not real. We can safely state that no-one invented Life and no-one is in Charge. As I said, Life is a big party.

## Q: How can I make money from Life? What's the business plan?

You can make good money by projecting your charismatic psychopathic inner-self onto others in the form of space ghosts, or similar hoaxes, if you are that kind of algorithm. The alternative algorithm is to find ways to make your Life useful to others, at which point you can reap a little of that benefit.

## Q: What's the license for Life? Is it open source?

Life uses a viral no-attribution share-alike license. No-one has successfully written down the Life license yet, so we can't ask the Open Source Initiative whether it's a compatible license.

## Q: How do I boot up my Life?

Most Lives come with convenient Parent plugins (primary, and backup), which will run your Lives for you until you are just getting cocky enough to believe things can't crash. After 18 you can choose to borrow money to try to upgrade your Life, or go rent your Life to the Man in exchange for food and shelter.

## Q: I don't like my Life, who can I complain to?

You will find good company with the 75% of others who dislike their Lives too. Usually, if you let them complain to you, they'll tolerate your complaining back. Mutual complaining is the basis of much social interaction. Note however that no matter how much you complain, no-one else can fix your life except you.

## Q: My Life is slow, and crashing, how do I fix it?

That's an awfully good question. There is no single answer. It is true that Life does randomly crash, and we just have to get used to that. Generally poor performance may be easier to work on. You may be connected to other Lives in dysfunctional patterns -- if you can identify these, change them. Your hardware may have issues, especially if you are an older generation model, or you abuse your co-processors. Life does also catch viruses and other malware. Consider a regular checkup.

## Q: My Life is lousy. Can I get an exchange or refund?

No, this is not possible for technical reasons we can't explain here. Just trust us. And if anyone offers you a refund or exchange, watch out, they are crooks. They just want your money or your Life. In Life, if something or someone appears to be too good to be true, they inevitably are.

## Q: I sat on my Life and bent it. How do I fix that?

Above all, if your Life still works, leave it alone. Trying to fix a Life that isn't broken will often make it worse. Some Lives are better bent than straight.

## Q: Why is Life so unreliable? It just doesn't work for me!

This is just a FAQ, not a full guide. On the one hand, you are the proud owner of a unique Life, yours from the day you are born to the day you die. On the other hand, there are no instructions. You can learn a lot from watching other people mess up their Lives. However the very best way to make your Life more reliable and overall, enjoyable, is to mess up yourself and then recover quickly.

## Q: I find Life kind of amateurish. Is there an Enterprise version?

You can buy lots of upgrades, and some of these do make a difference. However ultimately your Life has a fixed period of validity and there is nothing you can do about that. The best way to get free upgrades for your Life is to ask nicely. You can also be a sociopath, and that works for some people, especially those who want Enterprise Life.

## Q: Can I get someone to help me understand my Life?

Again, this is but a humble FAQ and a profound understanding of Life is typically something you will get only when it's tragically, and irreparably late. Beware anyone claiming they can help you with your Life, as the vast majority of people barely have their own Lives under control.

## Q: How do I contribute to Life? Where's the source code?

The Life community welcomes all contributions. The standard approach is to find a second contributor of the opposite gender, and then use the fork and merge model, repeating as necessary.

## Q: Without strong Intellectual Property Rights, surely no-one will invest in new life!

Oh, just go away!

## Q: What hardware do I need to run my Life on?

Life is entirely self-hosting, so you cannot switch the hardware out for a different box. Make the most of the hardware you have. Though you can extend it, and some people make a good job of changing it, it is usually a bad idea to make changes once you're up and running.

## Q: If I buy larger hardware, will it make my Life better?

You will get more stares, though that will not make your Life run better, and indeed will usually mess it up permanently.

## Q: My life and I always argue. What's the answer?

Do you mean "wife"? Then stop trying to always be right. 42.

  
![cover-kindle.jpg](http://hintjens.wdfiles.com/local--resized-images/blog:_psychopaths/cover-kindle.jpg/small.jpg)

Don't look for serial killersâ€¦ one in 25 of the people around you is a psychopath, hiding and living a secret life. Psychopaths take what they want, using their charm and wits. They feel only the emotions of a predator. In this book Pieter Hintjens decodes the mystery of the psychopath. Why do such people exist? How do they operate? And most critical of all, can we learn to avoid them, or escape them? The answers will enlighten you. This book delivers practical tools and techniques to survive the most difficult people.

**[Buy the paperback 290pp, $25.00](https://www.createspace.com/5558960)**  
**[Buy on Kindle, $4.99](http://www.amazon.com/gp/product/B016MRW9KS?*Version*=1&*entries*=0)**

Related articles by Pieter Hintjens:

> Your work has been an eye opener. I've read a number of books about psychopaths but your approach is unique in that it is written from the ground up but ultimately provides a robust and realistic theoretical framework to understand this fork in human psychology. -- Gareth H.

> After applying this material in life, things have stabilized greatly. Psychopaths at work can't touch me, friends are top notch. Remorseless whittling away the psychopaths has been a pleasant experience. -- Stewart M.

> The examples he cites are convincing, the explanations he offers are well thought out, and his solutions for the re-discovery of our personal power are strong and helpful. -- Fran Macilvey
